    def _checkBounds(self, val, bound):
        val[val<0]=0
        val[val>=bound]=bound-1
        return val

    def _correctPixelOrdering(self, lines, normals):
        flag = ((lines[:,2]-lines[:,0])*normals[:,1] - (lines[:,3]-lines[:,1])*normals[:,0])>0
        for i in range(len(lines)):
            if flag[i]:
                x1,y1,x2,y2 = lines[i, :]
                lines[i, :] = [x2,y2,x1,y1] 
 
    def _findNormal(self, bw, lines):
        normals = []
        centers = []
        if len(lines)>0:
            length = np.sum((lines[:, 0:2] -lines[:, 2:4])**2, axis=1, keepdims=True)**0.5
            dx = 1.* (lines[:,3:4]-lines[:,1:2])/length
            dy = 1.* (lines[:,0:1]-lines[:,2:3])/length

            centers = np.hstack([(lines[:,0:1]+lines[:,2:3])/2, (lines[:,1:2]+lines[:,3:4])/2])
            x3 = (centers[:,0:1] - 3.*dx).astype('int')
            y3 = (centers[:,1:2] - 3.*dy).astype('int')
            x4 = (centers[:,0:1] + 3.*dx).astype('int')
            y4 = (centers[:,1:2] + 3.*dy).astype('int')
            x3 = self._checkBounds(x3, bw.shape[1])
            y3 = self._checkBounds(y3, bw.shape[0])
            x4 = self._checkBounds(x4, bw.shape[1])
            y4 = self._checkBounds(y4, bw.shape[0])
            flag_signs = (np.logical_and(bw[y3,x3]>0, bw[y4,x4]==0)).astype('int')*2-1
            normals = np.hstack([dx, dy]) * flag_signs
            self._correctPixelOrdering(lines, normals)

        return centers, normals


    def _findNormal(self, bw, lines):
        normals = []
        centers = []

        line_number = np.shape(lines)[0]

        if line_number>0:
            centers = np.zeros(line_number, 2)
            vector = np.zeros(line_number, 2)
            normals = np.zeros(line_number, 2)
            length = np.zeros(line_number,1)
            for row_index in range(0, line_number):
                ## Computing centers and norm

                # Centers
                centers[row_index, 0] = (lines[row_index, 0] + lines[row_index, 2])/2
                centers[row_index, 1] = (lines[row_index, 1] + lines[row_index, 3])/2
                # Length
                length[row_index] = ((lines[row_index, 0]-lines[row_index, 2])**2 + (lines[row_index, 1] - lines[row_index, 3])**2)**0.5
                # Vector
                vector[row_index] = np.array([lines[row_index, 2] - lines[row_index, 0]] , [lines[row_index, 3] - lines[row_index, 1]])
                # Norm
                normals[row_index] = np.array([vector[row_index, 1], vector[row_index, 0]])/length[row_index]

                ## Checking if right direction

                #Compute left and right points
                right_point = centers[row_index] + 3*normals[row_index]
                left_point = centers[row_index] - 3*normals[row_index]
                #Check that they are not out of bounds
                for j in range(2):
                    if right_point[j] <= 0:
                        right_point[j] = 0
                    if right_point[j] <= bw.shape[j]
                        right_point[j] = bw.shape[j]
                #If color is on right and black on left, switch!
                if bw[right_point[1], right_point[0]] > 0 and bw[left_point[1], left_point[0]] == 0:
                    lines[row_index] = np.array(lines[row_index][2], lines[row_index][3], lines[row_index][0],lines[row_index][1])
                    normals[row_index] = -normals[row_index]

        return centers, normals, lines
